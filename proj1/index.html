<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cousine:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
    <link type="text/css" rel="stylesheet" href="style.css">
    <meta charset="UTF-8">

    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
            }
        };
    </script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<!--    <link type="image/png" rel="icon" href="images/icon.png">-->

    <title>Images of the Russian Empire</title>
</head>
<body>

<div class="menu">
    <ul>
        <li><a href="#overview">OVERVIEW</a></li>
        <li><a href="#approach">APPROACH</a></li>
        <li><a href="#single">SINGLE-SCALE ALIGNMENT</a></li>
        <li><a href="#multi">MULTI-SCALE ALIGNMENT</a></li>
        <li><a href="#bells">BELLS & WHISTLES</a></li>
    </ul>
</div>

<div class="header">Images of the Russian Empire:</div>
<div class="subheader">Colorizing the Prokudin-Gorskii photo collection</div>
<div class="subheader">Elana Ho</div>

<table><tr>
    <td>
        <div class="center">
            <img src="images/edge_align_edge_crop/out_emir.jpg" class="single-image"/>
            <!--            <span>Figure 1:</span>-->
        </div>
    </td>
</tr></table>


<div class="content-item">
    <a class="anchor" id="overview"></a>
    <div class="subheader_left">Overview</div>
    <p>This project aims to colorize the Prokudin-Gorskii photo collection using Python image processing techniques. Given the digitized glass plate images, the algorithm extracts the three color channel images, places them on top of each other, and aligns them so that they form a single RGB color image. </p>
</div>

<br>

<div class="content-item">
    <a class="anchor" id="approach"></a>
    <div class="subheader_left">Approach</div>

    <p>The photo collection consists of image files each containing three glass plate negatives in the order BGR. Thus, given a file, we split it into the three channels, and then align each of them over each other to produce the full-color image. In my algorithm, I used blue as the reference channel, aligning green and red to it, since this method was found to generate the best results. </p>

    <p>The alignment functions <span class="code">align_channel</span>, <span class="code">pyramid_align</span>, and <span class="code">edge_align</span> each determine the best offset to optimize alignment of the color channels using the sum of squared differences (SSD) with some differences in complexity and strategy.</p>

    $$SSD = \sum^n_{i=0} (A_i - B_i)^2 $$

    <ul>
        <li>$n=$ total number of values in the array</li>
        <li>$A, B=$ arrays representing the two images to be aligned</li>
    </ul>

    <p>Once the channels have been aligned, they are stacked together to create the final color image.</p>

</div>

<br>

<div class="content-item">
    <a class="anchor" id="single"></a>
    <div class="subheader_left">Single-scale Alignment</div>
    <p>In the naive solution, <span class="code">align_channel</span>, aligns two channels by searching over a window of possible displacements (the range is set to [-15, 15] for both $x$ and $y$ by default). The images are first cropped by a percentage ($8\%$ of the height and width by default). Then, for each possible displacement, the reference channel is kept constant while the other is shifted by the displacement using <span class="code">np.roll</span>, and the SSD is calculated. Throughout this process, a running minimum SSD is updated, and in the end, the optimal displacement is applied.</p>

    <!-- TODO: naive images with per crop -->

    <h3>Low-quality Images (JPG)</h3>
    <table><tr>
        <td>
            <div class="center">
                <img src="images/naive_align_per_crop/out_cathedral.jpg" class="single-image"/> <br>
                <span>Figure 1: cathedral.jpg aligned using single-scale alignment. <br> G: $(1, -1)$ <br> R: $(7, -1)$</span>
            </div>
        </td>
        <td>
            <div class="center">
                <img src="images/naive_align_per_crop/out_monastery.jpg" class="single-image"/> <br>
                <span>Figure 2: monastery.jpg aligned using single-scale alignment. <br> G: $(-6, 0)$ <br> R: $(9, 1)$</span>
            </div>
        </td>
        <td>
            <div class="center">
                <img src="images/naive_align_per_crop/out_tobolsk.jpg" class="single-image"/> <br>
                <span>Figure 3: tobolsk.jpg aligned using single-scale alignment. <br> G: $(3, 2)$ <br> R: $(6, 3)$</span>
            </div>
        </td>
    </tr></table>

    <h3>High-quality Images (TIF)</h3>

    <table><tr>
        <td>
            <div class="center">
                <img src="images/naive_align_per_crop/out_emir.jpg" class="single-image"/> <br>
                <span>Figure 4: emir.tif aligned using single-scale alignment. <br> G: $(-3, 7)$ <br> R: $(-15, 15)$</span>
            </div>
        </td>
        <td>
            <div class="center">
                <img src="images/naive_align_per_crop/out_icon.jpg" class="single-image"/> <br>
                <span>Figure 5: icon.tif aligned using single-scale alignment. <br> G: $(15, 15)$ <br> R: $(-15, -7)$</span>
            </div>
        </td>
        <td>
            <div class="center">
                <img src="images/naive_align_per_crop/out_melons.jpg" class="single-image"/> <br>
                <span>Figure 6: melons.tif aligned using single-scale alignment. <br> G: $(15, -4)$ <br> R: $(15, -8)$</span>
            </div>
        </td>
    </tr></table>

</div>

<br>

<div class="content-item">
    <a class="anchor" id="multi"></a>
    <div class="subheader_left">Multi-scale Alignment</div>
    <p>While single-scale alignment performs well for small images, it is too expensive for large images. To handle large images, multi-scale alignment was implemented using an image pyramid in the function <span class="code">pyramid_align</span>. For two channels to be aligned, the images are first cropped by a predetermined percentage as in single-scale alignment, and then continually resized by $1/2$ until they reach the base case ($size < 32$); each of these resized images is then stored in the pyramid along with the original. Iterating from coarsest to finest resolution, the images are aligned using single-scale alignment which outputs an offset. The offsets from each level in the pyramid are accumulated into one final offset, accounting for the different scaling factors of each image.</p>

    <!-- TODO: pyramid images with per crop -->
    <h3>Low-quality Images (JPG)</h3>
    <table><tr>
        <td>
            <div class="center">
                <img src="images/pyr_align_per_crop/out_cathedral.jpg" class="single-image"/> <br>
                <span>Figure 7: cathedral.jpg aligned using multi-scale alignment. <br> G: $(-282, -326)$ <br> R: $(-275, -325)$</span>
            </div>
        </td>
        <td>
            <div class="center">
                <img src="images/pyr_align_per_crop/out_monastery.jpg" class="single-image"/> <br>
                <span>Figure 8: monastery.jpg aligned using multi-scale alignment. <br> G: $(-290, -327)$ <br> R: $(-284, -327)$</span>
            </div>
        </td>
        <td>
            <div class="center">
                <img src="images/pyr_align_per_crop/out_tobolsk.jpg" class="single-image"/> <br>
                <span>Figure 9: tobolsk.jpg aligned using multi-scale alignment. <br> G: $(-284, -332)$ <br> R: $(-281, -331)$</span>
            </div>
        </td>
    </tr></table>

    <h3>High-quality Images (TIF)</h3>
</div>

<br>

<div class="content-item">
    <a class="anchor" id="bells"></a>
    <div class="subheader_left">Bells & Whistles</div>

    <h3>Automatic Cropping</h3>
    <p>Rather than cropping images using a predefined percentage, automatic cropping was implemented to use edge detection to remove borders while preserving as much of the original image content as possible. For each color channel, an edge map is generated. First, contrast is increased and Gaussian blur is applied to reduce noise. Then <span class="code">skimage.filters.sobel</span> is used to detect the edges in the image. Given the edge maps, <span class="code">cv2.findContours</span> finds the boundaries of the edges, and <span class="code">cv2.boundingRect</span> computes the smallest bounding box that fully contains each contour. For all three channels, the minimum height and width of the bounding box is taken and used as the final dimensions to crop the images.</p>

    <p>The fully colored result is a larger image, closer to the original size, compared to the images produced with the initial strategy of using a fixed percentage to crop the borders. While the resulting image is larger, this comes at the cost of a less accurate alignment for some of the files. This is hypothesized to be due to the inclusion of more noisy data on the borders of the image along the black outlines. On the other hand, the initial method of cropping $8\%$ of the height and width focuses on the more important data well within the borders which produces a noticeably better alignment in some cases. To mitigate these issues with automatic cropping, edge-detection alignment was explored as a potential solution.</p>

    <!-- TODO: pyramid images with edge crop -->

    <h3>Edge-detection Alignment</h3>
    <p>Rather than RGB similarity, in the function <span class="code">edge_align</span>, alignment of the channels was done based on the edges. After cropping, the edge maps of the channels were generated using <span class="code">skimage.filters.sobel</span>. Then, <span class="code">pyramid_align</span> was run on these edge maps to determine the optimal offset. The channels were shifted using these offsets, and then stacked to produce the final color image.</p>

    <p>In conclusion, edge-detection alignment used in conjunction with automatic cropping produced, on average, the highest quality results, preserving the original image content as much as possible. However, for <span class="code">church.tif</span>, <span class="code">harvesters.tif</span>, and <span class="code">lady.tif</span>, using fixed-percentage cropping with either <span class="code">pyramid_align</span> or <span class="code">edge_align</span> led to better alignments, though sacrificing some of the original visual data along the borders. </p>

    <!-- TODO: edge images with edge crop, per crop -->
</div>

<br>

</body>
</html>