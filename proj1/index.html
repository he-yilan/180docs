<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cousine:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
    <link type="text/css" rel="stylesheet" href="style.css">
    <meta charset="UTF-8">

    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
            }
        };
    </script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<!--    <link type="image/png" rel="icon" href="images/icon.png">-->

    <title>Images of the Russian Empire</title>
</head>
<body>

<div class="menu">
    <ul>
        <li><a href="#overview">OVERVIEW</a></li>
        <li><a href="#approach">APPROACH</a></li>
        <li><a href="#single">SINGLE-SCALE ALIGNMENT</a></li>
        <li><a href="#multi">MULTI-SCALE ALIGNMENT</a></li>
        <li><a href="#bells">BELLS & WHISTLES</a></li>
    </ul>
</div>

<div class="header">Images of the Russian Empire:</div>
<div class="subheader">Colorizing the Prokudin-Gorskii photo collection</div>
<div class="subheader">Elana Ho</div>

<table><tr>
    <td>
        <div class="center">
            <img src="images/edge_align_edge_crop/out_emir.jpg" class="single-image"/>
            <!--            <span>Figure 1:</span>-->
        </div>
    </td>
</tr></table>


<div class="content-item">
    <a class="anchor" id="overview"></a>
    <div class="subheader_left">Overview</div>
    <p>This project aims to colorize the Prokudin-Gorskii photo collection using Python image processing techniques. Given the digitized glass plate images, the algorithm extracts the three color channel images, places them on top of each other, and aligns them so that they form a single RGB color image. </p>
</div>

<br>

<div class="content-item">
    <a class="anchor" id="approach"></a>
    <div class="subheader_left">Approach</div>

    <p>The photo collection consists of image files each containing three glass plate negatives in the order BGR. Thus, given a file, we split it into the three channels, and then align each of them over each other to produce the full-color image. In my algorithm, I used blue as the reference channel, aligning green and red to it, since this method was found to generate the best results. </p>

    <p>The alignment functions <span class="code">align_channel</span>, <span class="code">pyramid_align</span>, and <span class="code">edge_align</span> each determine the best offset to optimize alignment of the color channels using the sum of squared differences (SSD) with some differences in complexity and strategy.</p>

    $$SSD = \sum^n_{i=0} (A_i - B_i)^2 $$

    <ul>
        <li>$n=$ total number of values in the array</li>
        <li>$A, B=$ arrays representing the two images to be aligned</li>
    </ul>

    <p>Once the channels have been aligned, they are stacked together to create the final color image.</p>

</div>

<br>

<div class="content-item">
    <a class="anchor" id="single"></a>
    <div class="subheader_left">Single-scale Alignment</div>
    <p>In the naive solution, align_channel, aligns two channels by searching over a window of possible displacements (the range is set to [-15, 15] for both x and y by default). The images are first cropped by a percentage (the border is 8% of the height and width by default). Then, for each possible displacement, the reference channel is kept constant while the other is shifted by the displacement using np.roll, and the SSD is calculated. Throughout this process, a running minimum SSD is updated, and in the end, the optimal displacement is applied.</p>
</div>

<br>

<div class="content-item">
    <a class="anchor" id="multi"></a>
    <div class="subheader_left">Multi-scale Alignment</div>
    <p>While single-scale alignment performs well for small images, it is too expensive for large images. To handle large images, multi-scale alignment was implemented using an image pyramid. For two channels to be aligned, the images are first cropped by a predetermined percentage as in single-scale alignment, and then continually resized by Â½ until they reach the base case (size < 32); each of these resized images is stored in the pyramid along with the original. Iterating from coarsest to finest resolution, the images are aligned using single-scale alignment which outputs an offset. The offsets from each level in the pyramid are accumulated into one final offset, accounting for the different scaling factors of each image.</p>
</div>

<br>

<div class="content-item">
    <a class="anchor" id="bells"></a>
    <div class="subheader_left">Bells & Whistles</div>
</div>


</body>
</html>